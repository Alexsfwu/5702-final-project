---
title: "EDAV Fall 2019 Final Project Group 23"
author: "Shaofeng Wu, Chengyou Ju, Mingrui Liu, Yujing Song"
output: html_document
---

```{r, include=FALSE}
knitr::opts_chunk$set(warning = FALSE, message = FALSE, echo = FALSE)
```

## I. Introduction

This project is created by Shaofeng Wu (sw3428), Chengyou Ju (cj2624), Mingrui Liu (ml4404), Yujing Song (ys3251) for STAT GR5702 Final Project Group 23.

As graduate students who are actively seeking jobs and internships, we come up with the idea that we can choose a topic related to the current employment condition in New York. After doing some research, we decide to focus on studying the recent job postings in New York. We want to see, for instance, salary ranges for different categories of jobs, what skills are preferred by a particular kind of jobs, or if there is a relationship between job locations and salaries.



## II. Data sources

Our data come from https://data.cityofnewyork.us/City-Government/NYC-Jobs/kpav-sd4t, which contains current job postings available on the City of New Yorkâ€™s official jobs site http://www.nyc.gov/html/careers/html/search/search.shtml. 

Mingrui is responsible for looking for and collecting the data. Since the data can be directly exported from the website as a `.csv` file, there is no major obstacle for us when gathering the data. After downloading the data from the website, we use the built-in `read.csv` method to read and store the data as a data frame for future manipulation.

This data frame has 3040 oberservations of 28 variables. Each entry represents a job posting on the website, while the columns represent the information about each job, including Business Title, Salary Range, Job Description, etc.

The only problem about the data is that in the origin `.csv` file, there are plenty of empty entries. Therefore, when we read data from the file and store as a data frame, we fill all these blank entries with NAs.



## III. Data transformation

Since the dataset is stored in a neat `.csv` file, we simply read the file using the `read.csv` method and store the data in the data frame `job`. Later, when we need some specific attributes of the job postings dataset, we can use simply `$` or pipes and the `%>%` operator to extract the columns we need.

```{r}
# Load all packages needed for our project
library(dplyr)
library(corpus)
library(ggplot2)
library(magrittr)
library(forcats)
library(tidyverse)
library(tm)
library(htmlTable)
library(ggridges)
library(lubridate)
library(RColorBrewer)
library(shiny)
library(extracat)
library(wordcloud2)
```
```{r}
job <- read.csv("data/raw/NYC_Jobs.csv") # Read data from csv file
job[job == ''] <- NA # Set empty slots as NAs

job <-job[!duplicated(job), ]
```



## IV. Missing values 

As mentioned above, we fill all empty slots in the original dataset with NAs. Then we draw a graph using `extracat::visna` to visualize the missing patterns of our dataset. The columns represent the 28 variables and the rows the missing patterns. The cells for the variables with missing values in a pattern are drawn in blue. The variables and patterns have been ordered by numbers of missings on both rows and columns. The bars beneath the columns show the proportions of missings by variable and the bars on the right show the relative frequencies of patterns.

```{r}
library(extracat)
visna(job, sort='b')
```

From the plot, we can tell that all values under the column **Recruitment Contact** are missing. Therefore, we decide to drop this column from our data frame. For other columns, we will keep these NAs for now.

```{r}
# Drop Recuitment Contact
job = job %>%
  select(-c("Recruitment.Contact"))
```



## V. Results

### 5.1 Job Count w.r.t Category

Since we want to study the total number of jobs for each job category and one particular job could belong to multiple categories, we extract all the categories related to a job, seperate them, and create a new data frame called `popular_category`, which stores the counts of different job categories. Then, in order to visualize the numbers of job postings among different categories, we draw a descending horizontal bar chart based on his new data frame. 

```{r}
categoryList <- job %>%
  filter(!is.na(Job.Category)) %>%
  select(Job.Category, Job.ID) %>%
  mutate(Job.Category = as.character(Job.Category),
         Job.Category = str_split(Job.Category, ",|&|,&"))

popular_category <-
  as.data.frame(unlist(categoryList["Job.Category"],use.names=FALSE)) %>%
  set_colnames("Category") %>%
  mutate(Category = trimws(Category,"both")) %>%
  filter(!is.na(Category)) %>%
  filter(Category !="") %>%
  filter(is.character(Category ))  %>%
  group_by(Category) %>%
  summarise(count = n()) %>%
  arrange(desc(count)) %>%
  slice(1:25)
  
ggplot(popular_category, aes(x = fct_reorder(Category,count), y = count)) +
  geom_col(color = "black", fill = "orange") +
  ggtitle("Job Count by Category") +
  labs(x = "Category", y = "Count") + 
  theme(plot.title = element_text(hjust = 0.5)) + 
  coord_flip()
```

From the graphs below, we can tell that **Architecture** and **Engineering** have the most job postings, while **Procurement Policy** and **Social Services** have the fewest.


### 5.2 Distributions of Salaries

We also want to study the distributions of salaries among different types of payroll. Since there are three payroll types in our data set, which are **Annual**, **Daily** and **Hourly**, we will draw three histograms to visualize the distributions. We take the mean of `Salary Range From` and `Salary Range To` as our salary for the histogram at the x-axis.

```{r}
job <- job %>%
  mutate(salary = Salary.Range.From+(Salary.Range.To-Salary.Range.From)/2)

Annual = job[job$Salary.Frequency=="Annual",]
ggplot(Annual, aes(salary)) +
  geom_histogram(bins = 40, color = "black", fill = "orange") +
  ggtitle("Salary Distribution (Annual)") + 
  labs(x = "Salary", y = "Count") + 
  theme(plot.title = element_text(hjust = 0.5))
```
```{r}
Daily = job[job$Salary.Frequency=="Daily",]
ggplot(data = Daily, aes(Daily$salary)) +
  geom_histogram(bins = 40, color = "black", fill = "orange") +
  ggtitle("Salary Distribution (Daily)") + 
  labs(x = "Salary", y = "Count") + 
  theme(plot.title = element_text(hjust = 0.5))
```
```{r}
Hourly = job[job$Salary.Frequency=="Hourly",]
ggplot(data = Hourly, aes(Hourly$salary)) +
  geom_histogram(bins = 40, color = "black", fill = "orange") +
  ggtitle("Salary Distribution (Hourly)") + 
  labs(x = "Salary", y = "Count") + 
  theme(plot.title = element_text(hjust = 0.5))
```

From these three plots above, we have the following obeservations: 
* For most of the jobs, the salaries are given annually. There are also some jobs which have hourly salaries. Only a few of those jobs have daily salaries. 
* For salaries calculated annually, it has approximately right-skewed normal distribution, which means that most jobs do not have a relatively high salaries.
* For salaries calculated daily, there is no specific pattern regarding the distribution. Some jobs have relatively low daily salaries, while others have much higher salaries. 
* For salaries calculated hourly, most of them has a relatively low value, but there are still some jobs have relatively high hourly salaries. 

```{r}
temp = Hourly %>% 
  filter(salary < 10)
```

Then, We also look into our data and find out more information about our salary distribution. For insace, for houly paied jobs, Stationary Engineer and City Medical Specialist have extremly high hourly salaries, while College Aide has low hourly salaries.


### 5.3 Word Clouds for Text Information

Meanwhile, we also want to study the minimum qualification requirements and preferred skills for the available jobs in NYC. We want to find if there are any patterns in these two columns and if we can extract any useful information from them. In order to illustrate our findings graphfically, we decide to use Word Clouds to show the most frequent words in these texts.

So what is Word Clouds? Word Clouds is visual representations of text data. They are useful for quickly perceiving the most prominent terms, which makes them widely used in media and well understood by the public. A Word Cloud is a collection of words depicted in different sizes. The bigger and bolder the word appears, the greater frequency within a given text and the more important it is.

In order to extract meaningful vocabularies from the text descriptions, we take advantage of the text mining package `tm` in R. This package is based on the ideas of Natural Language Processing (NLP). It have methods that can tranform all words to lowercases, remove words that are uninformative in Enlighs such as "a" and "the", and get rid of whitespaces and punctuations.

After these manipulations on the text data, we can create a new data frame of word frequencies. We can also sort it by frequency and find out the most frequent words under minimum qualification requirements and preferred skills for all jobs or for any particular category of jobs that we are interested in.

```{r}
job_docs <- VCorpus(VectorSource(job)) # Whole dataset
# inspect(job_docs)
job_mini_req <- VCorpus(VectorSource(job$Minimum.Qual.Requirements)) # Minimum Qual Requirements
# inspect(job_mini_req)
job_pref_skil <- VCorpus(VectorSource(job$Preferred.Skills)) # Preferred Skills
# inspect(job_pref_skil)
```
```{r}
# Tech Jobs
tech_jobs <- subset(job, Job.Category == "Technology, Data & Innovation")
# dim(tech_jobs) # There should be 28 jobs related to technology
job_tech_mini_req <- VCorpus(VectorSource(tech_jobs$Minimum.Qual.Requirements))
# inspect(job_tech_mini_req)
job_tech_pref_skil <- VCorpus(VectorSource(tech_jobs$Preferred.Skills))
# inspect(job_tech_pref_skil)
```
```{r}
# All Jobs cross Minimum Qual Requirements
# toSpace <- content_transformer(function (x , pattern) gsub(pattern, " ", x))
# job_mini_req <- tm_map(job_mini_req, toSpace, "/")
# job_mini_req <- tm_map(job_mini_req, toSpace, "@")
# job_mini_req <- tm_map(job_mini_req, toSpace, "\\|")
job_mini_req <- tm_map(job_mini_req, content_transformer(tolower))
job_mini_req <- tm_map(job_mini_req, removeNumbers)
job_mini_req <- tm_map(job_mini_req, removeWords, stopwords("english"))
job_mini_req <- tm_map(job_mini_req, removeWords, c("the", "one", "two", "for", "must", "year")) 
job_mini_req <- tm_map(job_mini_req, removePunctuation)
job_mini_req <- tm_map(job_mini_req, stripWhitespace)
# job_mini_req <- tm_map(job_mini_req, stemDocument)
```
The table below demonstrates the 20 most frequent words in Minimum Qual Requirements among all jobs in out dataset.
```{r}
mini_req_matrix <- TermDocumentMatrix(job_mini_req)
mini_freq_m <- as.matrix(mini_req_matrix)
mini_freq_v <- sort(rowSums(mini_freq_m), decreasing=TRUE)
mini_freq <- data.frame(word = names(mini_freq_v), freq=mini_freq_v)
# head(mini_freq, 20)
htmlTable(head(mini_freq, 20), caption="Minimum Qual Requirements in All Jobs Word Frequency", header=c("Word", "Frequency"), rnames=FALSE)
```
<!-- ```{r} -->
<!-- library(wordcloud2) -->
<!-- library(webshot) -->
<!-- webshot::install_phantomjs(force = TRUE) -->
<!-- mini_freq_graph <- wordcloud2(data=mini_freq, color='random-light', backgroundColor='black') -->
<!-- library("htmlwidgets") -->
<!-- saveWidget(mini_freq_graph,"mini_freq_graph.html", selfcontained = F) -->
<!-- ``` -->
```{r}
library(wordcloud2)
wordcloud2(data=mini_freq, color='random-light', backgroundColor='black', size=0.8)
```

```{r}
# All Jobs cross Preferred Skills
job_pref_skil <- tm_map(job_pref_skil, content_transformer(tolower))
job_pref_skil <- tm_map(job_pref_skil, removeNumbers)
job_pref_skil <- tm_map(job_pref_skil, removeWords, stopwords("english"))
job_pref_skil <- tm_map(job_pref_skil, removeWords, c("the", "one", "two", "for", "must", "year")) 
job_pref_skil <- tm_map(job_pref_skil, removePunctuation)
job_pref_skil <- tm_map(job_pref_skil, stripWhitespace)
```
The table below demonstrates the 20 most frequent words in Preferred Skills among all jobs in out dataset.
```{r}
pref_skil_matrix <- TermDocumentMatrix(job_pref_skil)
pref_freq_m <- as.matrix(pref_skil_matrix)
pref_freq_v <- sort(rowSums(pref_freq_m), decreasing=TRUE)
pref_freq <- data.frame(word = names(pref_freq_v), freq=pref_freq_v)
pref_freq <- pref_freq[-1,]
# head(pref_freq, 20)
htmlTable(head(pref_freq, 20), caption="Preferred Skills in All Jobs Word Frequency", header=c("Word", "Frequency"), rnames=FALSE)
```
```{r}
library(wordcloud2)
wordcloud2(data=pref_freq, color='random-light', backgroundColor='black', size=0.8)
```


```{r}
# Tech Jobs cross Minimum Qual Requirements
job_tech_mini_req <- tm_map(job_tech_mini_req, content_transformer(tolower))
job_tech_mini_req <- tm_map(job_tech_mini_req, removeNumbers)
job_tech_mini_req <- tm_map(job_tech_mini_req, removeWords, stopwords("english"))
job_tech_mini_req <- tm_map(job_tech_mini_req, removeWords, c("the", "one", "two", "for", "must", "year")) 
job_tech_mini_req <- tm_map(job_tech_mini_req, removePunctuation)
job_tech_mini_req <- tm_map(job_tech_mini_req, stripWhitespace)
```
The table below demonstrates the 20 most frequent words in Minimum Qual Requirements among all jobs in out dataset.
```{r}
tech_mini_matrix <- TermDocumentMatrix(job_tech_mini_req)
tech_mini_freq_m <- as.matrix(tech_mini_matrix)
tech_mini_freq_v <- sort(rowSums(tech_mini_freq_m), decreasing=TRUE)
tech_mini_freq <- data.frame(word = names(tech_mini_freq_v), freq=tech_mini_freq_v)
# head(tech_mini_freq, 20)
htmlTable(head(tech_mini_freq, 20), caption="Minimum Qual Requirements in Technology Related Jobs Word Frequency", header=c("Word", "Frequency"), rnames=FALSE)
```
```{r}
library(wordcloud2)
wordcloud2(data=tech_mini_freq, color='random-light', backgroundColor='black', size=0.8)
```


```{r}
# Tech Jobs cross Preferred Skills
job_tech_pref_skil <- tm_map(job_tech_pref_skil, content_transformer(tolower))
job_tech_pref_skil <- tm_map(job_tech_pref_skil, removeNumbers)
job_tech_pref_skil <- tm_map(job_tech_pref_skil, removeWords, stopwords("english"))
job_tech_pref_skil <- tm_map(job_tech_pref_skil, removeWords, c("the", "one", "two", "for", "must", "year")) 
job_tech_pref_skil <- tm_map(job_tech_pref_skil, removePunctuation)
job_tech_pref_skil <- tm_map(job_tech_pref_skil, stripWhitespace)
```
```{r}
tech_pref_matrix <- TermDocumentMatrix(job_tech_pref_skil)
tech_pref_freq_m <- as.matrix(tech_pref_matrix)
tech_pref_freq_v <- sort(rowSums(tech_pref_freq_m), decreasing=TRUE)
tech_pref_freq <- data.frame(word = names(tech_pref_freq_v), freq=tech_pref_freq_v)
tech_pref_freq <- tech_pref_freq[-1,]
# head(tech_pref_freq, 20)
htmlTable(head(tech_pref_freq, 20), caption="Preferred Skills in Technology Related Jobs Word Frequency", header=c("Word", "Frequency"), rnames=FALSE)
```
```{r}
library(wordcloud2)
wordcloud2(data = tech_pref_freq, color='random-light', backgroundColor='black', size=0.8)
```

We can have plenty of observations from the four Word Clouds. For instance, we can see that for both Minimum Qual Requirements and Preferred Skills, *experience* is the most frequent word in all these four graphs, which makes sense, since previous working experience is indeed very important for applicants.

Also, when comparing all jobs with technological jobs, we notice that for tech jobs prefer to hire employees with skills related to technology, since vocabularies like *computer* and *programming* appears a lot in these texts. Even some words about specific skills, such as *sql*, appear in our most frequent word list.

Meanwhile, in all these four graphs, vocabularies like *skills*, *knowledge*, *management*, *communication* appear plenty of times. This makes sense since all employers want to hire people who have solid skills and are good at communication and cooperation.

Finally, in general, we find that minimum requirements of all jobs and tech jobs graphs share almost the same set of frequent words, which we believe is due to the fact that **minimum** requirements are similar for all kinds of jobs.


## 5.4 Tech Jobs Postings Trends
```{r}
tech_job = job[job$Job.Category == 'Technology, Data & Innovation', ]

tech_job %>%
  filter(!is.na(tech_job$Full.Time.Part.Time.indicator)) %>%
  ggplot(aes(Full.Time.Part.Time.indicator)) + 
  geom_bar(fill = 'lightblue') +
  ggtitle("Number of Tech Job Postings w.r.t Full/Part Time") + 
  labs(x = "Full/Part Time", y = "Count") +
  theme(plot.title = element_text(hjust = 0.5))
```


```{r}
tech_job %>%
  filter(!is.na(tech_job$Salary.Frequency)) %>%
  ggplot(aes(Salary.Frequency)) + 
  geom_bar(fill = 'lightblue') +
  labs(x = "Salary frequency") + 
  ggtitle("Number of Tech Job Postings w.r.t Salary Frequency") + 
  labs(x = "Salary Frequency", y = "Count") +
  theme(plot.title = element_text(hjust = 0.5))
```


```{r}
tech_job %>%
  filter(!is.na(tech_job$Civil.Service.Title)) %>%
  ggplot(aes(fct_rev(fct_infreq(Civil.Service.Title)))) + 
  geom_bar(fill = 'lightblue') +
  labs(x = "Civil service title") + 
  coord_flip()
```


```{r}
tech_job %>%
  filter(!is.na(tech_job$Work.Location)) %>%
  ggplot(aes(fct_rev(fct_infreq(Work.Location)))) + 
  geom_bar(stat = 'count', fill = 'lightblue') +
  labs(x = "Work location") + 
  coord_flip()
```


```{r}
tech_job %>%
  group_by(Civil.Service.Title) %>%
  summarise(mean_salary = mean(salary)) %>%
  ggplot(aes(x = reorder(Civil.Service.Title, mean_salary), y = mean_salary)) +
  geom_col(fill = 'lightblue') + 
  labs(x = 'Civil service title', 
       y = 'Average annual salary') + 
  coord_flip()
```


## VI. Interactive component
```{r}
# for(i in 1:nrow(job)){
#  result = geocode( as.character(job$Work.Location[i]) , source = 'google', output = 'latlona')
#  if(!is.na(result[1])){
#    job$longitude[i] = as.numeric(result[1])
#    job$latitude[i] = as.numeric(result[2])
#    job$address[i] = as.character(result[3])
#  }else{
#    job$latitude[i] = NA
#    job$longitude[i] = NA
#    job$address[i] = NA
#  }
# }

#write_csv(job, 'job_with_lat_long.csv')
```

## VII. Conclusion

### 2.2 Short Summary of Initial Investigations

From those three plots above, we can have the following obeservations:
1. For most of the jobs, the salaries are given annually. Meanwhile, there are also some jobs which have hourly salaries. Only a few of those jobs have daily salaries.
2. For salaries calculated annually, it has approximately right-skewed normal distribution.
3. For salaries calculated daily, there is no specific pattern regarding the distribution. Some jobs have relatively low daily salaries, while others have much higher salaries.
4. For salaries calculated hourly, most of them has a relatively low value, but there are still some jobs have relatively high hourly salaries.

```{r}
#converting salary on hourly scale anddaily scale to yearly scale
#no of working days in US in a year: 261 source: 
#no of working hours in US in a day: 8.4 hours 
job <- job %>% mutate(Annual_salary = if_else( Salary.Frequency == "Annual", round((Salary.Range.From + Salary.Range.To)/2,2),
                                 if_else(Salary.Frequency == "Daily", round((Salary.Range.From + Salary.Range.To)*261/2,2),
                                         round((Salary.Range.From + Salary.Range.To)*261*8.4/2,2))
                                 )
                               )

##make the list of category of each job id as a single observations 
df<-unnest(categoryList, cols = c(Job.Category))%>%
  mutate(Job.Category = trimws(Job.Category,"both"))%>%
  filter(Job.Category!="")


mdy(job$Posting.Date)

df_all<-left_join(df, job, by = "Job.ID")

df_popular<-df%>%
  filter(Job.Category %in% popular_category$Category)%>%
  merge(.,job[c("Job.ID","Annual_salary","Posting.Date")], by = "Job.ID")%>%
  unique()%>%
  mutate(month = lubridate::month(mdy(Posting.Date)))%>%
  group_by(Job.Category,month)%>%
  mutate(count = n())

ggplot(df_popular, aes(x=month,y=Job.Category,fill=Job.Category))+
  geom_density_ridges(scale = 3, show.legend = FALSE) + theme_ridges()+
  labs(x="month",y="count")+
  ggtitle("The counts of insects treated with different insecticides.")+
  theme(plot.title = element_text(hjust = 0.5))


## all job posting with only category, anuual salary and job id



ggplot(df_popular,aes(x = reorder(Job.Category,Annual_salary,FUN=mean), y = Annual_salary)) +
geom_boxplot(color = "black", fill = "orange") +
ggtitle("Distribution of Salaries w.r.t Different Categories") + 
labs(x = "Category", y = "Anual Salary") + 
theme(plot.title = element_text(hjust = 0.5)) +
  coord_flip()




```



This boxplot gives us a general idea of the salary distribution for different kinds of jobs from the highest highest salary to lowest mean salary. For instance, we can see that jobs of Building Operations & Maintenance in general have lower salaries than those of Information Technology & Telecommunmications.

There are a lot of information in the job description and job requirements. Extracting the useful information from these features could be a challenging work.

In conclusion, these are all we have done right now. We identify the number of job postings with respect to different job categories. We also check the salaries of jobs with different salary frequency. Last but not least, we also inspect the salary range for different categories by drawing a boxplot. I think we are off a great start, and we will continue our analysis on the dataset from here.


# 3. Analyzing part

## 3.1 Word Cloud

Word Frequency and WordCloud from here:
```{r}
#library(SnowballC)
#library(wordcloud)
#library(RColorBrewer)
#set.seed(1234)
#wordcloud(words = d$word, freq = d$freq, min.freq = 1,
          #max.words=200, random.order=FALSE, rot.per=0.35, 
          #colors=brewer.pal(8, "Dark2"))
```


## 3.2 Explore the relationship between salary and its range

Noticed that the salaries may have huge differences when the differences of positions, in this section, we are trying to explore the relationship between salary and its ranges.

Here we need to clarify that the "salary" means the average of each job salary and the "salary range" means the difference between the maximum salary and minimum salary of this job position.

To make sure each job salary can be paired in the same unit, we convert all the salaries originally to annual salary, extract the columns we may need, and remove the duplications.

```{r}
job <- job %>% mutate(Annual_salary_range = if_else( Salary.Frequency == "Annual", 
                                                    round(abs(Salary.Range.From -Salary.Range.To),2),
                                            if_else(Salary.Frequency == "Daily", 
                                                    round(abs(Salary.Range.From -Salary.Range.To)*261,2),
                                                round(abs(Salary.Range.From - Salary.Range.To)*261*8.4,2))
                      ) 
            ) 
# extract a dataframe that contains the dolumns that we may need to use
extractdf <- data.frame("id" = job$Job.ID, 
                        "agency" = job$Agency,
                        "posting_type" = job$Posting.Type,
                       "type" = job$Full.Time.Part.Time.indicator,
                       "num_positions" = job$X..Of.Positions,
                       "AnnualSalaryMean" = job$Annual_salary,
                       "AnnualSalaryRange" = job$Annual_salary_range)
# remove the duplication
extractdf <- unique(extractdf) 
#Make sure each column in the property data type.
extractdf$id <- as.integer(as.character(extractdf$id))
extractdf$num_positions <- as.integer(as.character(extractdf$num_positions))
extractdf$AnnualSalaryMean <- as.numeric(as.character(extractdf$AnnualSalaryMean))
extractdf$AnnualSalaryRange <- as.numeric(as.character(extractdf$AnnualSalaryRange))
```

```{r}
library(devtools)
#devtools::install_github('madlogos/recharts')
library(recharts)
library(rCharts)
mydf1 <- na.omit(extractdf)
```

```{r}
options(RCHART_WIDTH = 600, RCHART_HEIGHT = 400)
rPlot(AnnualSalaryRange~AnnualSalaryMean | type, data = mydf1, color = 'type', type = 'point')
```

<p> The plot above shows the relation between salary range and mean of salary of each job position divided by two subplot based on the full-time job or part-time job.  

<p>  Overall, the distributions of two types of job, full-time and part-time, are not have a huge differences, but the amount of part-time jobs are greatly less than full-time jobs.  Most of jobs with the salary lower than 150k/yr and the range of these jobs' salaries are less than 50k.  When the salary range over 50k, there is an obvious positive relationship between these two.  

<p> Though most of part time jobs take salary hourly or daily instead of yearly, when all of them convert to annual salary, they did not have obvious difference.  Therefore, we will put them together to check in the next plot.


```{r}
p <-nPlot(AnnualSalaryRange~AnnualSalaryMean,group='type',data=mydf1, type='scatterChart') 
p$yAxis(axisLabel = "Annual Salary Range")
p$xAxis(axisLabel = "Annual salary Mean")
p$chart(showDistX = TRUE, showDistY = TRUE)
p$chart(color = c("blue","yellow"))
p
```

<p> From the interactive scatter plot above, in general, the higher salary we have, the larger salary range will have.  Moreover, the variance of salary range is increasing with the increasing of the salary income.  Noticed that there are many jobs only provided a fixed number of salary so their ranges are zero.  Most of salary range is less than 40000 dollars, and most salary mean are gathered between 20000 to 100000 dollars.  When the salary range is between 80000 to 140000 dollars, there is an obvious positive raltionship between salary mean and its range.  This is suitable for both part-time jobs or full-time jobs.


To figure out the mean of salary and its range based on different categories of jobs, we merge the job categories in our extracted table. 

```{r}
mydf = total <- merge(extractdf,df,by.x = "id",by.y = "Job.ID")
mydf$Job.Category <- as.factor(mydf$Job.Category)
cate_freq_mean = as.data.frame(table(mydf$Job.Category))
cate_freq_mean$Annual_salary_mean <- NA
for (i in 1:110){cate_freq_mean$Annual_salary_mean[i] <- mean(mydf$AnnualSalaryMean[mydf$Job.Category == cate_freq_mean$Var1[i]])}
cate_freq_mean$cate_sala_max <- NA
for (i in 1:110){cate_freq_mean$cate_sala_max[i] <- max(mydf$AnnualSalaryMean[mydf$Job.Category == cate_freq_mean$Var1[i]])}
cate_freq_mean$cate_sala_min <- NA
for (i in 1:110){cate_freq_mean$cate_sala_min[i] <- min(mydf$AnnualSalaryMean[mydf$Job.Category == cate_freq_mean$Var1[i]])}
cate_freq_mean$Annual_salary_range <- cate_freq_mean$cate_sala_max - cate_freq_mean$cate_sala_min
cate_freq_mean = cate_freq_mean[order(cate_freq_mean$Freq,decreasing = TRUE),]
```


```{r}
top_popular_cate = head(cate_freq_mean,30)
hPlot(Annual_salary_range~Annual_salary_mean,data = top_popular_cate,type = 'bubble', group = "Var1", size = 'Freq',title = 'Relationship between annual salary range and amount based on top 30 popular job categories')
```

<p> The bubble plot shows the top 30 popular job categories in the relation between annual salary and its range.  The top 30 popular job categories means the amount of job types published in the NY job website.  From the plot, we noticed that most of them have salary range between 100k to 200k and the annual salary mean crossed from 60k to 90k dollars.  The size of bubbles displaies the amount of a type of work that is published online.  In these job categories, most job categories that have annual salary over 80k are  technology related.


<p> To see all the categories the following plot provided information:

```{r}
hPlot(Annual_salary_range~Annual_salary_mean,data = cate_freq_mean,type = 'bubble', group = "Var1", size = 'Freq',title = 'Relationship between annual salary range and amount based on job categories')
```

<p> The above plot shows all the categories.  In general, the salary range are wider compared with the top 30 categories.  Planning Maintenance and Producement Building Operations have a extremly high annual salary mean, they all over 150k dollars/year.  Human Resource Finance and Health Policy are also obviously distinguished with others since their annual are over 100k.  The next group of categories with the annual salay mean between 80k to 100k, they mostly related with technology, innovation, finance, and service.  The next group of categories with mean salary between 60k to 80k, their categories are similar with the group of 80k to 90k, but this group have the large size of needness.  For the salary group less than 60k, they also have low annual salary range, their sizes of needness online are also small.




## 3.3 Technology job posting trends

```{r}
tech_job = job[job$Job.Category == 'Technology, Data & Innovation', ]

tech_job %>%
  filter(!is.na(tech_job$Full.Time.Part.Time.indicator)) %>%
  ggplot(aes(Full.Time.Part.Time.indicator)) +
  geom_bar(fill = 'lightblue') +
  labs(x = "Full time and part time")

```


```{r}
tech_job %>%
  filter(!is.na(tech_job$Salary.Frequency)) %>%
  ggplot(aes(Salary.Frequency)) + 
  geom_bar(fill = 'lightblue') +
  labs(x = "Salary frequency")
```


```{r}
tech_job %>%
  filter(!is.na(tech_job$Civil.Service.Title)) %>%
  ggplot(aes(fct_rev(fct_infreq(Civil.Service.Title)))) + 
  geom_bar(fill = 'lightblue') +
  ggtitle("Job Count by Civil Service Title") +
  labs(x = "Civil Service Title", y = "Count") + 
  theme(plot.title = element_text(hjust = 0.5)) + 
  coord_flip()
```


```{r}
tech_job %>%
  filter(!is.na(tech_job$Work.Location)) %>%
  ggplot(aes(fct_rev(fct_infreq(Work.Location)))) + 
  geom_bar(fill = 'lightblue') +
  ggtitle("Job Count by Work Location") +
  labs(x = "Work Location", y = "Count") + 
  theme(plot.title = element_text(hjust = 0.5)) + 
  coord_flip()
```


```{r}
tech_job %>%
  filter(!is.na(tech_job$Civil.Service.Title)) %>%
  group_by(Civil.Service.Title) %>%
  summarise(mean_salary = mean(Annual_salary)) %>%
  ggplot(aes(x = reorder(Civil.Service.Title, mean_salary), y = mean_salary)) +
  geom_col(fill = 'lightblue') + 
  ggtitle("Job Count by Work Location") +
  labs(x = "Civil Service Title", y = "Average Annual Salary") + 
  theme(plot.title = element_text(hjust = 0.5)) + 
  coord_flip()
```

As a result, for technology job postings in New York City:
  
  - Full time jobs more than part time jobs.
  
  - Popular Location is Brooklyn.
  
  - Most wanted Civil Service is Computer Systems Manager.
  
  - Most jobs have over 60000 dollars average annual salary.
  
  


# 4. Conclusion


# 5. Future Works

(If we are provided more time, what we want to do?)



# 6. Requirements and References

## 6.1 Reqirements

### 6.1.1 File format
(You don't have to use the same format for this assignment -- PSet 5, part A -- and the final project itself.)

Choices are:

pdf_document  

html_document  

bookdown book: https://bookdown.org/yihui/bookdown/

shiny app: https://shiny.rstudio.com/  

(Remember that it's ok to have pieces of the project that don't fit into the chosen output format; in those cases you can provide links to the relevant material.)

    We decide to use the html_document as our output format.

### 6.1.2 Instructions
Be sure to review the final project instructions (https://edav.info/project.html), in particular the new section on reproducible workflow (https://edav.info/project.html#reproducible-workflow), which summarizes principles that we've discussed in class.


### 6.2 References

```{r}
library(leaflet)
job = read_csv('data/clean/job_with_lat_long.csv')%>%
  filter(!is.na(latitude)) %>%
  filter(longitude < -74.0060 + 1) %>%
  filter(longitude > -74.0060 - 1) %>%
  filter(latitude < 40.7128 + 0.8) %>%
  filter(latitude > 40.7128 - 0.8)

job$Full.Time.Part.Time.indicator[job$Full.Time.Part.Time.indicator == 'F'] = 'Full time'

job$Full.Time.Part.Time.indicator[job$Full.Time.Part.Time.indicator == 'P'] = 'Part time'

job = job %>%
  select(-'Job.Category')
df_popular_test = df_popular[,-3]

job = unique(merge(df_popular_test, job, by = 'Job.ID'))

high_salary_geocodes = job %>%
  filter(Annual_salary > mean(Annual_salary))
low_salary_geocodes = job %>%
  filter(Annual_salary < mean(Annual_salary))

#add custom color column
high_salary_geocodes$color = rep('red', nrow(high_salary_geocodes))
low_salary_geocodes$color = rep('blue', nrow(low_salary_geocodes))

job = rbind(high_salary_geocodes, low_salary_geocodes) %>%
  filter(!is.na(Annual_salary))

ui <- bootstrapPage(
  tags$style(type = "text/css", "html, body {width:100%;height:100%}"),
  leafletOutput("map", width = "100%", height = "100%"),
  absolutePanel(top = 10, left = 50,
                selectInput(inputId = "Full_part_time","Choose full time or part time:",
                            c("All", "Full time", "Part time")
                ),
                selectInput(inputId = "chosen_cate","Choose the category that you want:",
                            c("All", popular_category$Category)
                ),
                sliderInput("Annual_salary", "Slide bar to choose the range of salary:", 
                            50000, 100000,
                            value = range(50000:100000), step = 10000
                )
  )
)

server <- function(input, output, session) {
  
  # Reactive expression for the data subsetted to what the user selected
  
  filteredData <- reactive({
    temp <- job
    if(input$Full_part_time !='All'){
      temp <- temp[temp$Full.Time.Part.Time.indicator == input$Full_part_time, ]
    }
    if (input$chosen_cate !='All') {
      temp <- temp[temp$Job.Category == input$chosen_cate, ]
    }
    temp[temp$Annual_salary >= input$Annual_salary[1] & temp$Annual_salary <= input$Annual_salary[2], ]
  })
  
  output$map <- renderLeaflet({
    leaflet() %>% setView(lat = 40.7128, lng = -74.0060, zoom = 11) %>%
      addTiles() %>% 
      addCircleMarkers(data = filteredData(),  
                       lng = ~longitude, 
                       lat = ~latitude, 
                       radius = 3, 
                       color = ~color,
                       popup = ~paste("<strong>Angency</strong>", Agency,
                                  "<br /><strong>Job Title:</strong>", Business.Title,
                                  "<br /><strong>Annual Salary:</strong>","$",Annual_salary,
                                  "<br /><strong>Category:</strong>",Job.Category))%>%
  addLegend("bottomright", 
            colors = c('red', 'blue'), 
            labels = c('high_salary', 'low_salary'),
            title = "Salary",
    opacity = 1
  )
  })
}

shinyApp(ui, server,options=list(height=530))



```

